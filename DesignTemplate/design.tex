% !TEX root = SystemTemplate.tex
\chapter{Design  and Implementation}
 This section describes the design details for the overall system as well as individual major components. As a user, you will have a good understanding of the implemetation details without having to look into the code. Here is the  


\begin{itemize}
  \item Ask if the user if the program needs to generate test cases
  \item If the user's answer is yes: 
	 \begin{itemize}
		\item Get the requirements for test cases
 	 	\item Generate {\tt.tst} files and corresponding {\tt .ans} files using {\tt golden.cpp}
	\end{itemize}
  \item (If no) get all the {\tt .tst} files and add them to a vector 
  \item Get all {\tt .cpp} files and compile them into executable files
  \item Create summary file
  \item For each {\tt .cpp} files in the directory: 
 	\begin{itemize}
 		\item Create {\tt .log} file for current student
		\item For all {\tt .tst} file in the vector:
		\begin{itemize}
			 \item Run student file using current test case
 			\item If pass the increment the number of passed tests, and output the score to student's {\tt .log} file
			 \item If fail, check if it is a critical test, if so, the student has failed, else output the score to the {\tt .log} file
		\end{itemize}
	\end{itemize}
  \item Check if the user wants more cases
  \item If yes, then restart from the beginning
  \item If no:
	\begin{itemize}
  		\item Output student's overall grade to summary file
  		\item Close current student's {\tt .log} file	
	\end{itemize}
  
\item Check if there are more {\tt .cpp} files to be processed
  \item If yes, then repeat the previous steps
  \item If no:
	\begin{itemize}
 		\item Close summary file
 		\item End test program
	\end{itemize}
\end{itemize}


\section{Traversing Subdirectories }

\subsection{Technologies  Used}
The dirent.h library is used for traversing subdirectories.

\subsection{Design Details - Adding Test Cases to a Vector}

\begin{lstlisting}

void drct_recur (char * buffer)
{
    get_folders ( buffer );
    get_files (  buffer );
}

void get_folders( char * buffer )
{
    DIR *a_folder;
    struct dirent *dir_handle;
    vector<string> paths;
    bool subdir = false;
    int attrib;
    char path[ PATH_MAX ] = "";
    strcat( path, "~" );
    strcat( path, buffer );
    a_folder = opendir( buffer );
    if ( a_folder == NULL ) // call directory
    {
        return;
    }

    dir_handle = readdir( a_folder );
    if ( dir_handle == NULL )
    {
        return;
    }
    strcpy( path, buffer );
    // search for and step into folders
    do
    {
        attrib = ( int )dir_handle->d_type;
        if ( attrib == 4 && strcmp( dir_handle->d_name, "." ) != 0
             && strcmp( dir_handle->d_name, ".." ) != 0)
        {
            // set to true when we find and step into a folder
            subdir = true;
            char name[ PATH_MAX ];
            strcpy( name, dir_handle->d_name );
            strcat( path, "/" );
            strcat( path, dir_handle->d_name );
            paths.push_back( path );
        }
        if ( subdir )
        {
            strcat( path, "/.." );
            getcwd( path, sizeof( path ));
        }
        // reset test variable that determines 
        // if we found and processed a folder
        subdir = false;
        // reset path
        strcpy( path, buffer );
    } while ( ( dir_handle = readdir( a_folder ) )!= NULL );

    while( !paths.empty() )
    {   
        string temp =  paths.back();
        paths.pop_back();
        char pth[ PATH_MAX ];
        strcpy( pth, temp.c_str() );
        drct_recur( pth );
    }

    closedir( a_folder );
}

void get_files( char * buffer )
{
    DIR *a_file;
    struct dirent *dir_handle;
    a_file = opendir( buffer );
    dir_handle = readdir( a_file );
    string ext = dir_handle->d_name;
    string path;
    string name = dir_handle->d_name;

    if ( dir_handle != NULL )
    {
        do // search for files with "tst" extension
        {
            path = buffer;
            name = dir_handle->d_name;
            /*Check to see if the file has an extension BUT special case
              so that test.cpp file is not added to the compiled file stack.*/
            if( name.find_last_of( "." ) != string::npos && name != "test.cpp" )
                ext = name.substr( name.find_last_of( "." ) );
            else 
                ext = "";
            if ( 8 == ( int )dir_handle->d_type 
                && ( ext == ".tst"  || ext == ".ans" || ext == ".cpp" ) )
            {
                path += ( "/" + name );
                if( ext == ".tst" )
	                tstLocations.push_back( path );
                else if( ext == ".ans" )
		        ansLocations.push_back( path );
                else if(ext == ".cpp")
		        cppLocations.push_back( path );
            }

        }
        while ( ( dir_handle = readdir( a_file ) ) != NULL );
    }

    closedir( a_file );
}
\end{lstlisting}

\section{Running the Program Using Test Cases }

\subsection{Technologies  Used}
The software was designed in the Linux Environment provided to the group by the University.



\subsection{Design Details - Running Files and Comparing to Test Case}


\begin{lstlisting}
int run_file(string cpp_file, string test_case) //case_num
{
    string case_out(case_name(test_case, "out"));
    //set up piping buffers
    string buffer1("");
    string buffer2(" &>/dev/null < ");
    string buffer3(" > ");

    buffer1 += remove_extension(cpp_file);
    buffer1 += buffer2;
    buffer1 += test_case;
    buffer1 += buffer3;
    buffer1 += case_out;

    system(buffer1.c_str());

    //0 = Fail, 1 = Pass
    return result_compare(test_case);
}

int result_compare(string test_file)
{
    int length;
    ifstream fin;

    string case_out(case_name(test_file, "out"));
    string case_ans(case_name(test_file, "ans"));
    string case_tmp(case_name(test_file, "tmp"));   //create temp file
    
    //perform diff command
    string buffer("diff ");
    buffer += case_out + " " + case_ans + " > " + case_tmp;
    system(buffer.c_str());    
    fin.open(case_tmp.c_str(), ios::binary);    //open file
    fin.seekg(0, ios::end);                     //cursor at EOF
    length = fin.tellg();                       //find cursor position
    fin.close();
    buffer = "rm " + case_tmp;
    system(buffer.c_str());
    buffer = "rm " + case_out;
    system(buffer.c_str());
    if ( length == 0 ) //File is empty, no diff between .ans and .tmp
        return 1;
    else
        return 0;
}
\end{lstlisting}

\section{Generating Test Cases}

\subsection{Technologies  Used}

\subsection{Design Details}

